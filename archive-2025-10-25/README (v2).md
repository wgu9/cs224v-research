# 智能编程代理的跨会话学习与执行监控

## 🎯 Business Problem

现代开发者在使用智能编程代理（Cursor / Claude Code / Copilot 等）时，主要耗时在反复喂相同背景与纠正跑题。常见三类痛点：

### 1. 每次都从零开始（Q2：跨会话学习）
上周刚解决过的类问题，代理这周仍需重新理解项目与探索路径，经验无法沉淀与迁移，导致重复劳动。

### 2. 输出粒度不匹配（Q3：动态抽象）
初学者需要步骤与示例，资深工程师只要策略与不变量。现有系统难以按用户水平 × 任务难度自动调节抽象层级，输出要么啰嗦、要么含糊。

### 3. 长任务易跑偏（Q1：执行监控/偏航守卫）
多步修复/重构中，代理容易偏离目标（例：只要求改文档，却去改依赖），缺少目标‑检查点‑守卫的持续对齐。

---

## 🏗️ 我们的方案（同一底座，三段合一）

### 共同底座：同一条事件总线（Event Bus）与目标图（Goal Graph）
- **事件总线**：按步骤记录 where/what/why/evidence（改了什么、为何改、证据）
- **目标图**：四检查点 复现→修改→测试→回归，定义允许动作与验收条件

### Q2｜跨会话学习
从过去成功轨迹抽取"模式卡（Pattern Cards）"（触发条件/步骤/不变量/反例/评测样例），在新任务自动检索与注入，复用经验而非复读历史。

### Q3｜动态抽象
同一张模式卡提供两档视图——terse（要点/不变量）与 guided（示例/坑点/测试），按用户画像 + 任务难度自动路由。

### Q1｜执行监控/偏航守卫
在四检查点上运行 Scope/Plan/Test/Evidence 守卫，计算 drift_score，超阈提醒/回滚，保证长任务不跑题。

**目标**：把编程代理从"一次性助手"，升级为"会成长、会复用、会自我约束"的合作者。

---

## 📋 端到端例子（人人能懂的文档任务）

**目标**：只把 README.md 翻译成中文（doc‑only）  
**实际**：代理同时修改了 requirements.txt（新增依赖）→ 典型跑题

### Q1 检测（同一事件流）
- `where=requirements.txt` 不在 `allowed_paths=[README.md, docs/**]` → ScopeGuard=1.0
- modify 阶段编辑了非白名单文件 → PlanGuard=1.0
- 合成 drift_score ≥ 0.5 ⇒ 弹出偏航提醒 + 一键回滚（撤销依赖改动）

### Q2 抽卡（由本次成功经验沉淀）
生成模式卡 `pc_doc_only_change`：
- **triggers**：documentation‑only / translate readme
- **steps**：白名单 README.md, docs/**；禁止改 requirements.*；运行 doc_lang_check 与 whitelist_diff_check
- **invariants**：仅白名单文件变更；语言==目标语

下次遇到"文档/翻译"任务，自动检索触发该卡，先天防跑题。

### Q3 呈现（同一卡，两档视图）
- **terse**（给熟练者）：3 条不变量 + 1 条禁改规则，一屏读完
- **guided**（给新手）：如何配置白名单/语言检测/例外申请，附示例与坑点

由 `profiles/<user>.json`（自报水平 + 历史首试成功率）自动路由。

---

## 📊 评测与指标（社区对齐 + 我们新增）

### 社区对齐
SWE‑bench 系列的 %Resolved（把补丁打入基线快照跑测试）；我们本地保存 base_commit + unified diff 与其一致。

### 我们新增
- **Q2**：模式复用率、首试成功率↑、平均回合数/用时↓
- **Q3**：视图匹配度（guided 下新手更稳、terse 下专家不受干扰）
- **Q1**：偏航检出率、误报率、偏航恢复时间（warn→回到正确检查点的步数/秒）
- **消融**：baseline → +pattern → +pattern+views → +pattern+views+guards；同一批任务成对比较

---

## 🚀 为什么现在（差异化）

- 现有"记忆"多停留在会话内或"对话级备忘"；缺少面向代码模式的跨会话学习与动态抽象路由
- 我们用同一份事件数据同时支撑 Q2/Q3/Q1，既能复用经验，又能约束执行，避免"学会了但又跑偏"的拉扯

---

## 📝 实施计划

### 1) 立刻改 README（半页内）

**目标三条（按优先级）**
- **P0**：从过往会话中学会"可复用模式"（pattern cards）并在新任务触发
- **P1**：按用户水平与任务难度，动态选择解释/提示粒度
- **P2**：提供基本的目标-检查点与偏航提醒（为 P0/P1 提供基础设施）

**一句话方法**：事件化日志 → 模式抽取（去场景化）→ 检索与重排（再场景化）→ 动态呈现（分层解释）

**评测**：Pattern 复用率（P0）、相似问题首试成功率（P0）、用时/回合数（P0）、偏航恢复时间（P2）、用户满意度/解释匹配度（P1）

**风险与门槛**：Week 3 Gate＝"可用的模式抽取+检索在简单任务上明显提升首试成功率"

### 2) 架构只做这五件（其他都推迟）

1. **Event Bus**（本地或简单后端）：记录 `{when, where(file:line), what(diff/AST), why(rationale), evidence(test)}`
2. **Pattern 抽取器**（P0）：把多次相似事件子图→模式卡（触发条件、步骤、约束/反例、评估）。先用启发式+少量模板
3. **检索与重排**（P0）：新任务解析成 goal sketch，用向量+规则检索模式卡；按匹配度与风险（约束冲突）重排
4. **动态抽象路由**（P1）：每张模式卡提供两档内容：要点版（策略与不变量）/ 详解版（示例与坑），按用户画像+任务难度路由
5. **轻量执行监控**（P2）：最小化 checkpoint（复现→修改→测试→回归）+ 两条硬规则（禁改目录白/黑名单、未过前置测试禁止合并）

### 3) 开发顺序（两到四周排程）

#### Week 1：打底
- 上 Event Bus；采 3–5 个真实修复样例，手工标注→沉淀 3 张模式卡（例如：空指针防护、依赖版本冲突、边界条件 off-by-one）
- README 改版 & 指标面板草图（只需记录表格/CSV）

#### Week 2：能用
- 接上 检索+重排 到你的编程代理/IDE；新任务时自动推荐模式卡与"要点版"指引；打通最小 P2 监控（4 个 checkpoint）
- 做一次 A/B（无模式 vs 有模式卡）的小测，记录首试成功率、回合数、用时

#### Week 3：过 Gate
- 上 动态抽象路由（以"用户自报水平 + 历史成功率"做简单画像）
- 完成"相似任务明显提升首试成功率"的演示；补 README 的 ablation：去掉检索/去掉抽象层的对比

#### Week 4：打磨与复盘
- 扩大到 8–10 张模式卡；补偏航恢复时间与复用率可视化；写清失败案例与改进方向

### 4) Q1 只做"最低可用"
固定 4 个 checkpoint + 2 条守卫规则即可；不做复杂规划器。把时间都投给 模式抽取/检索（P0）与动态抽象（P1）。

### 5) 立刻可做的三件小事（今天）
1. 把 README 头部换成上面的 P0/P1/P2 目标+评测
2. 从你已有会话里手工提炼 3 张模式卡（各写"触发条件/步骤/不变量/反例/评估"五段）
3. 在 IDE 里加一个"模式建议面板"（即使先用硬编码 JSON 也行），跑一次端到端 demo

按这个执行，你的项目会围绕 Q2 打穿、以 Q3 作为学术/产品亮点，同时保留足够的 Q1 支撑，不会再"像做三个项目"。

---

## 💡 总结

没关系，我们不用找文件，直接给你一个可放进 README 的例子，说明：
- 👉 business problem（商业痛点）怎么讲
- 👉 并且自然串起 Q2 + Q3 + Q1 三个部分
# 分析数据
下面是定稿版（中文），已按你要的口径修正易混点：created_at≠Issue时间、hints_text定义、test_patch不计分、PASS_TO_PASS数量不再误导性描述，并去掉了"Django通常单文件修复"的说法。

## SWE-bench 数据字段（定稿）

| 字段名 | 类型 | 含义 | Q1 用途（与你的守护/评测相关） | 重要说明 |
|--------|------|------|----------------------------|---------|
| instance_id | str | 任务唯一标识符；格式：repo_owner__repo_name-PR_number | 日志主键、结果追踪 | 用于标识/索引任务 |
| repo | str | GitHub 仓库：owner/name（如 astropy/astropy） | 定位仓库与代码下载；可做仓库维度统计/切片 | 无"单文件修复"的规律性假设 |
| base_commit | str | 评测前的基线 commit（PR 合入前的仓库状态） | 设置/checkout 评测环境 | 从该 commit 开始修改与运行测试 |
| problem_statement | str | Issue 标题+正文（模型/Agent的唯一自然语言输入） | Plan Guard：解析目标；Test Guard：推断需验证点 | 评测时不暴露测试用例 |
| FAIL_TO_PASS | str（JSON） | 需要被修复而必须通过的测试名单（字符串列表） | Test Guard：必须全部通过；最终计分使用 | 运行前需 json.loads()→List[str] |
| PASS_TO_PASS | str（JSON） | 需在修复前后都通过的测试名单（防回归） | Test Guard：回归检测；Evidence Guard：可抽样运行 | 数量因仓库而异，通常很多；解析同上 |
| patch | str | Gold patch（不含测试改动）的 git diff | 事后评估：Scope Precision/Recall、对比研究 | 评测与运行时禁止使用 |
| test_patch | str | PR 对测试文件的 git diff | 供离线分析/理解测试变化 | 与 FAIL_TO_PASS/PASS_TO_PASS 不同维度；不直接计分 |
| difficulty | str | 难度标签（仅 Verified 提供） | 可用于阈值/分层分析（例如 Q1/Q3 分桶） | 取值："<15 min fix", "15 min - 1 hour", "1-4 hours", ">4 hours" |
| hints_text | str | 在解决 PR 的第一次 commit 之前，Issue 中出现的评论文本 | 可选额外上下文 | 常为空 |
| created_at | str | 解决 PR 的创建时间（ISO 格式） | 时间切片、分布统计 | 不是 Issue 创建时间 |
| version | str | 安装/依赖版本号标记 | 环境安装（pip/conda） | 与官方评测环境保持一致 |
| environment_setup_commit | str | 用于环境安装脚本的特殊 commit | 环境配置/可复现实验 | 搭配 version 使用 |

## 重要提示（定稿）

- FAIL_TO_PASS 与 PASS_TO_PASS 均为 JSON 字符串；运行前先 json.loads() 转为 List[str] 再使用。
- 计分只看测试：FAIL_TO_PASS 全过 + PASS_TO_PASS 不回归；patch / test_patch 不参与计分，仅供离线分析。
- difficulty 仅在 SWE-bench Verified 中提供，可用于分层/阈值自适应。

---

## 评测输入/输出/对齐关系（极简）

- **输入（给 Agent）**：problem_statement + 仓库在 base_commit 的完整代码快照（容器/工作区）。
- **输出（由 Agent 产生）**：对代码库的实际修改（编辑操作/生成的 patch）。
- **判定**：在评测容器内运行测试：
  - FAIL_TO_PASS 全部通过；
  - PASS_TO_PASS 全部仍通过（无回归）。
- **禁止用作提示**：patch 与 test_patch。


## Worked Example

SWE-bench Verified 单行示例解析 + Q1 端到端流程

  本文基于 SWE-bench Verified 的单个实例，说明各字段用途、哪些作为 Q1 的输入、Q1 如何判定漂移（drift），以及完整的端到端评测流程。示例采用任务：
  django__django-11119。

  — — —

  一、示例任务与字段作用（Verified）

  - instance_id（任务唯一标识）
      - 示例："django__django-11119"
      - 作用：唯一定位用例，格式 {repo_name}__{issue_number}。
      - Q1：用于日志与结果关联。
  - repo（仓库）
      - 示例："django/django"
      - 作用：指定代码库。
      - Q1：配合 base_commit 做环境定位；也可作为规模信号（大仓常见“小改动”模式）。
  - base_commit（起始提交）
      - 示例："d16bfe05a744909de4b27f5875fe0d4ed41ce607"
      - 作用：指定评测起点的仓库版本。
      - Q1：环境准备（checkout）。
  - difficulty（难度分桶，Verified 独有）
      - 示例："<15min"（实际分桶常见：<15min、15–60min、1–4h、>4h）。
      - 作用：人工标注的时间难度等级；用于分层分析。
      - Q1：可作为动态策略信号（如简单任务改动文件数阈值更严格）。
  - problem_statement（问题描述 = GitHub Issue 文本）
      - 示例（节选）："Engine.render_to_string() should honor the autoescape attribute ..."
      - 作用：给 Agent 的任务文字描述。
      - Q1：
          - Plan Guard：从描述解析目标模块/函数（如 Engine.render_to_string）；可与 allowed_paths 联合使用。
          - Test Guard：辅助推断需要验证的行为维度（非必须）。
  - FAIL_TO_PASS（必须从 FAIL 变 PASS 的测试）
      - 示例：["test_autoescape_off (template_tests.test_engine.RenderToStringTest)"]
      - 作用：判定“修复是否成功”的硬标准。
      - Q1：
          - 在线监控：可作为证据参考（不直接暴露给 Agent）。
          - 事后评估：用于官方评测 resolved 计算。
  - PASS_TO_PASS（必须保持 PASS 的测试）
      - 示例：497 个（数量因项目而异）。
      - 作用：防止回归；与 FAIL_TO_PASS 一起构成 resolved 的判据。
      - Q1：
          - 在线监控：可采样运行作为 Evidence 证据。
          - 官方评测：最终以全量 PASS_TO_PASS 结果为准。
  - patch（ground truth 标准答案，diff）
      - 示例（节选）：将 Context(context) 改为 Context(context, autoescape=self.autoescape)。
      - 作用：人类修复供对照分析；不允许作为 Agent 输入。
      - Q1：
          - 事后 Scope 分析：计算 Scope Precision/Recall（与 agent_patch 的文件/行对比）。
          - 漂移复盘：分析 agent 为什么跑偏（多改/漏改）。

  — — —

  二、Q1 输入/输出最小契约

  - 作为 Q1 输入（在线监控需要）
      - instance_id, repo, base_commit
      - problem_statement（Plan/Evidence 工具）
      - difficulty（可选：动态阈值校准）
      - agent 的实时行为（编辑的文件列表、是否运行测试等）
  - 不给 Agent、仅事后评估用
      - FAIL_TO_PASS / PASS_TO_PASS（官方评测）
      - patch（ground truth，供 Scope 指标与事后分析）
  - Q1 期望输出（在线监控）
      - 每步事件的守卫评分与合成分：scope_guard / plan_guard / test_guard / evidence_guard / drift_score
      - 动作建议：ok / warn / rollback_advisory
      - 运行摘要：各守卫失败计数、事件级最大漂移、run 级聚合漂移
  - 评测期望输出（官方）
      - resolved：all(FAIL_TO_PASS == PASS) AND all(PASS_TO_PASS == PASS)
      - 额外指标（研究报告用）：Scope Precision/Recall、Drift Rate、action_mix

  — — —

  三、Q1 四守卫与示例逻辑（口径一致）

  - Scope Guard（默认权重 0.4）
      - 检查是否越界编辑；支持文件精确匹配 + 目录通配视图（如 src/**）。
      - 简单任务（如 <15min）若修改 >3 文件 → 红旗（阈值可根据仓库/难度校准）。
  - Plan Guard（0.3）
      - 检查当前阶段与工具是否匹配；从 problem_statement 启发解析目标模块/函数并与计划对齐；与 allowed_paths 联合降低误报。
  - Test Guard（0.2）
      - 检查是否运行了相关/必要测试（在线：可使用 runner 别名、pytest -k 解析；事后：对照 FAIL_TO_PASS）。
  - Evidence Guard（0.1）
      - 检查是否提供了足够证据（如运行过测试、错误日志、diff 摘要等）。
  - 合成分与建议动作
      - 合成：drift_score = 0.4scope + 0.3plan + 0.2test + 0.1evidence
      - 建议：drift < 0.5 → ok；0.5–0.8 → warn；≥0.8 → rollback advisory（阻断提交）
      - 上线策略：shadow（只告警）→ 阈值收敛 → advisory（建议回滚/阻断提交）

  — — —

  四、端到端流程（Verified x Q1）

  1. 选择实例

  - 从 verified.jsonl 读取第 i 行，解析为 instance（仅取必要字段）。

  2. 准备 Agent 输入（test-based benchmark 标准）

  - 输入给 Agent：problem_statement + repo + base_commit（不提供 FAIL/PASS/patch）。
  - Agent 生成 agent_patch（唯一产物）。

  3. 在线 Q1 监控（不依赖 LLM，或可选用小模型提升目标解析）

  - 记录 agent 的编辑与命令事件（生成 events.jsonl）。
  - 运行四守卫，输出 guards.jsonl（包含合成 drift_score 与 ok/warn/rollback_advisory）。

  4. 官方评测（SWE-bench harness）

  - 环境准备：checkout(repo, base_commit)；安装依赖。
  - 应用 agent_patch。
  - 运行 FAIL_TO_PASS（必须从 FAIL→PASS）。
  - 运行 PASS_TO_PASS（必须保持 PASS）。
  - 得到 resolved = True/False。

  5. 事后分析与指标

  - Scope：
      - gold_files = files(ground_truth_patch)
  - Q1 总结：run 级聚合漂移（事件 max→run 平均）、action_mix、主要失败守卫/原因。

  6. 持久化产物

  - 记录：agent_patch、events.jsonl、guards.jsonl、评测结果、Scope 指标、Q1 摘要。

  7. （可选）Q2/Q3 后续

  - Q2：从“低漂移 + 成功”的 run 中抽取模式卡（triggers/sequence/constraints）；
  - Q3：根据 drift 与失败守卫路由视图（concise/guided），并注入模式卡要点。

  — — —

  五、LLM 的使用点

  - 必须项（Q1）：无。Q1 守卫与评测均为规则/测试驱动。
  - 可选项（提升效果，但非必需）：
      - Plan Guard 目标解析（从 problem_statement 解析目标模块/函数/目录）。
      - 生成更稳健的 allowed_paths（与仓库结构/难度结合）。
  - 注意：patch（ground truth）绝不作为 Agent 输入，仅用于事后分析。

  — — —

  六、总结要点

  - Verified 的核心优势：难度标签 + 人工质检（主榜口径）。
  - SWE-bench 评测是 test-based：输入问题→输出 patch→跑测试，允许多种正确修复。
  - Q1 在线监控不影响官方判定；它评估“过程合规性（drift）”，官方评测评估“结果正确性（resolved）”。
  - 事后可计算 Scope Precision/Recall 与 Drift 指标，结合难度做分层分析；为 Q2/Q3 提供可靠数据底座。